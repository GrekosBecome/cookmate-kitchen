import { PantryItem, ShoppingItem, PantryUnit } from '@/types';
import { categorizeByAisle, groupByAisle, Aisle } from './aisles';

export interface ToolCall {
  id: string;
  name: string;
  arguments: any;
}

export interface ToolResult {
  id: string;
  result: any;
}

export interface ToolExecutionContext {
  pantry: PantryItem[];
  cart: ShoppingItem[];
  addShoppingItem: (item: Omit<ShoppingItem, 'id' | 'addedAt'>) => void;
  removeShoppingItem: (id: string) => void;
  updateShoppingItem?: (id: string, updates: Partial<ShoppingItem>) => void;
  recordOperation: (type: string, data: any) => void;
  undoLastOperation: () => { success: boolean; message: string };
}

const SUBSTITUTE_MAP: Record<string, string[]> = {
  milk: ['oat milk', 'almond milk', 'soy milk', 'coconut milk'],
  butter: ['olive oil', 'coconut oil', 'ghee', 'margarine'],
  egg: ['flax egg', 'chia egg', 'applesauce', 'banana'],
  flour: ['almond flour', 'coconut flour', 'oat flour', 'rice flour'],
  sugar: ['honey', 'maple syrup', 'agave', 'stevia'],
  chicken: ['tofu', 'tempeh', 'seitan', 'chickpeas'],
  beef: ['mushrooms', 'lentils', 'black beans', 'jackfruit'],
  cheese: ['nutritional yeast', 'cashew cheese', 'vegan cheese'],
  cream: ['coconut cream', 'cashew cream', 'oat cream'],
  yogurt: ['coconut yogurt', 'almond yogurt', 'soy yogurt'],
};

export function executeToolCall(toolCall: ToolCall, context: ToolExecutionContext): any {
  const { name, arguments: args } = toolCall;
  
  console.log(`Executing tool: ${name}`, args);
  
  switch (name) {
    case 'getPantry':
      return context.pantry.map(item => ({
        name: item.name,
        qty: item.qty,
        unit: item.unit,
        confidence: item.confidence,
      }));
      
    case 'getCart':
      return context.cart.filter(item => !item.bought).map(item => ({
        name: item.name,
        qty: item.suggestedQty,
        unit: item.unit,
        reason: item.reason,
      }));
      
    case 'addToCart': {
      const newItem: Omit<ShoppingItem, 'id' | 'addedAt'> = {
        name: args.name,
        suggestedQty: args.qty || 1,
        unit: args.unit as PantryUnit,
        reason: args.reason || 'missing_from_recipe',
        autoGenerated: false,
        bought: false,
      };
      
      // Check if already exists
      const existing = context.cart.find(
        item => item.name.toLowerCase() === args.name.toLowerCase() && !item.bought
      );
      
      if (existing) {
        return { 
          added: false, 
          message: `${args.name} is already in your shopping list`,
          item: existing 
        };
      }
      
      context.addShoppingItem(newItem);
      
      // Record for undo
      const addedItem = context.cart[context.cart.length - 1];
      context.recordOperation('addToCart', { 
        id: addedItem.id, 
        name: args.name 
      });
      
      return { 
        added: true, 
        item: { name: args.name, qty: args.qty, unit: args.unit } 
      };
    }
      
    case 'removeFromCart': {
      const itemToRemove = context.cart.find(
        item => item.name.toLowerCase() === args.name.toLowerCase() && !item.bought
      );
      
      if (!itemToRemove) {
        return { 
          removed: false, 
          message: `${args.name} not found in shopping list` 
        };
      }
      
      // Record for undo before removing
      context.recordOperation('removeFromCart', { 
        item: { ...itemToRemove } 
      });
      
      context.removeShoppingItem(itemToRemove.id);
      
      return { 
        removed: true, 
        item: { name: itemToRemove.name } 
      };
    }
      
    case 'updateCartItem': {
      const itemToUpdate = context.cart.find(
        item => item.name.toLowerCase() === args.name.toLowerCase() && !item.bought
      );
      
      if (!itemToUpdate) {
        return { 
          updated: false, 
          message: `${args.name} not found in shopping list` 
        };
      }
      
      // Record previous state for undo
      context.recordOperation('updateCartItem', {
        id: itemToUpdate.id,
        previous: { ...itemToUpdate },
      });
      
      // Update via remove and re-add (since we don't have direct update)
      context.removeShoppingItem(itemToUpdate.id);
      context.addShoppingItem({
        name: args.name,
        suggestedQty: args.qty !== undefined ? args.qty : itemToUpdate.suggestedQty,
        unit: (args.unit as PantryUnit) || itemToUpdate.unit,
        reason: itemToUpdate.reason,
        autoGenerated: false,
        bought: false,
      });
      
      return { 
        updated: true, 
        item: { 
          name: args.name, 
          qty: args.qty, 
          unit: args.unit 
        } 
      };
    }
      
    case 'suggestSubstitutes': {
      const missing = args.missing.toLowerCase();
      const alternatives: string[] = [];
      
      // Check direct substitutes
      for (const [key, subs] of Object.entries(SUBSTITUTE_MAP)) {
        if (missing.includes(key) || key.includes(missing)) {
          alternatives.push(...subs);
          break;
        }
      }
      
      // Check what's in pantry
      const inPantry = context.pantry
        .filter(item => !item.used && (item.confidence || 100) > 30)
        .map(item => item.name);
      
      return { 
        missing: args.missing,
        alternatives: alternatives.length > 0 
          ? alternatives.slice(0, 3) 
          : ['Try similar items you have in pantry'],
        inPantry: inPantry.slice(0, 5),
      };
    }
      
    case 'summarizeCart': {
      const activeCart = context.cart.filter(item => !item.bought);
      const grouped = groupByAisle(activeCart);
      
      const summary: Record<Aisle, any[]> = {} as any;
      let totalItems = 0;
      
      Object.entries(grouped).forEach(([aisle, items]) => {
        if (items.length > 0) {
          summary[aisle as Aisle] = items.map(item => ({
            name: item.name,
            qty: item.suggestedQty,
            unit: item.unit,
          }));
          totalItems += items.length;
        }
      });
      
      return { 
        byAisle: summary, 
        totalItems 
      };
    }
      
    case 'undoLastChange': {
      const result = context.undoLastOperation();
      return { 
        undone: result.success, 
        message: result.message 
      };
    }
      
    default:
      return { error: `Unknown tool: ${name}` };
  }
}

export function executeToolCalls(
  toolCalls: ToolCall[], 
  context: ToolExecutionContext
): ToolResult[] {
  return toolCalls.map(toolCall => ({
    id: toolCall.id,
    result: executeToolCall(toolCall, context),
  }));
}
